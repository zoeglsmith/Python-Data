<!-- 
RSS generated by JIRA (8.20.10#820010-sha1:ace47f9899e9ee25d7157d59aa17ab06aee30d3d) at Sat May 27 09:43:11 UTC 2023

It is possible to restrict the fields that are returned in this document by specifying the 'field' parameter in your request.
For example, to request only the issue key and summary append 'field=key&field=summary' to the URL of your request.
-->
<rss version="0.92" >
<channel>
    <title>ASF JIRA</title>
    <link>https://issues.apache.org/jira</link>
    <description>This file is an XML representation of an issue</description>
    <language>en-uk</language>    <build-info>
        <version>8.20.10</version>
        <build-number>820010</build-number>
        <build-date>22-06-2022</build-date>
    </build-info>


<item>
            <title>[CXF-5762] Connection leak after SocketTimeoutException using Asynchronous Client HTTP Transport</title>
                <link>https://issues.apache.org/jira/browse/CXF-5762</link>
                <project id="12310511" key="CXF">CXF</project>
                    <description>&lt;p&gt;We are using CXF with Async HTTP Transport to call web services of another system (about 15000 requests per day). Some messages sent each day end in SocketTimeoutException. About 15-30 out of them cause connection leak (logs provided below).&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;2014.05.23 08:27:26.801 org.apache.cxf.services.SubscriberLineManagerPortTypeService.SubscriberLineManagerPortTypePort.SubscriberLineManagerPortType INFO  [HLAPI-68] AbstractLoggingInterceptor:239 Outbound Message
---------------------------
ID: 277
Address: http://10.250.32.140:8082/HighLevelApiWS-2.4/services/SubscriberLineManager
Encoding: UTF-8
Http-Method: POST
Content-Type: text/xml
Headers: {Accept=[*/*], Connection=[Keep-Alive], SOAPAction=[&quot;urn:getAll&quot;]}
Payload: &amp;lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&amp;gt;
&amp;lt;soap:Envelope xmlns:soap=&quot;http://schemas.xmlsoap.org/soap/envelope/&quot;&amp;gt;
  &amp;lt;soap:Body&amp;gt;
    &amp;lt;ns2:getAll xmlns=&quot;http://pojo.web.api.icc.services.osp.in.alcatel.com/xsd&quot; xmlns:ns2=&quot;http://implementation.web.api.icc.services.osp.in.alcatel.com&quot; xmlns:ns3=&quot;http://web.api.icc.services.osp.in.alcatel.com/xsd&quot; xmlns:xsi=&quot;http://www.w3.org/2001/XMLSchema-instance&quot;&amp;gt;
      &amp;lt;ns2:subscriberLineId&amp;gt;
        &amp;lt;ceSepGroupName xsi:nil=&quot;true&quot;/&amp;gt;
        &amp;lt;communityId xsi:nil=&quot;true&quot;/&amp;gt;
        &amp;lt;platformName xsi:nil=&quot;true&quot;/&amp;gt;
        &amp;lt;serviceRetailerName&amp;gt;HEYAH&amp;lt;/serviceRetailerName&amp;gt;
        &amp;lt;subscriberLineId&amp;gt;0048888522289&amp;lt;/subscriberLineId&amp;gt;
        &amp;lt;subscriberLineIdType&amp;gt;1&amp;lt;/subscriberLineIdType&amp;gt;
        &amp;lt;validityDate xsi:nil=&quot;true&quot;/&amp;gt;
      &amp;lt;/ns2:subscriberLineId&amp;gt;
      &amp;lt;ns2:additionalParameters&amp;gt;
        &amp;lt;chargingCommand xsi:nil=&quot;true&quot;/&amp;gt;
        &amp;lt;depth&amp;gt;1&amp;lt;/depth&amp;gt;
        &amp;lt;extCorrelationIdentifier&amp;gt;71001465||&amp;lt;/extCorrelationIdentifier&amp;gt;
      &amp;lt;/ns2:additionalParameters&amp;gt;
    &amp;lt;/ns2:getAll&amp;gt;
  &amp;lt;/soap:Body&amp;gt;
&amp;lt;/soap:Envelope&amp;gt;

--------------------------------------
2014.05.23 08:27:26.802 org.apache.cxf.transport.http.asyncclient.AsyncHTTPConduitFactory$3 DEBUG [HLAPI-68] DefaultAsyncRequestDirector:208 [exchange: 277] start execution
2014.05.23 08:27:26.803 org.apache.cxf.transport.http.asyncclient.AsyncHTTPConduitFactory$3 DEBUG [HLAPI-68] DefaultAsyncRequestDirector:625 [exchange: 277] Request connection for {}-&amp;gt;http://10.250.32.140:8082
2014.05.23 08:27:26.804 org.apache.cxf.transport.http.asyncclient.AsyncHTTPConduitFactory$2 DEBUG [HLAPI-68] PoolingClientAsyncConnectionManager:172 Connection request: [route: {}-&amp;gt;http://10.250.32.140:8082][total kept alive: 2; route allocated: 2 of 1000; total allocated: 2 of 5000]
2014.05.23 08:27:26.805 org.apache.cxf.transport.http.asyncclient.AsyncHTTPConduitFactory$2 DEBUG [HLAPI-68] PoolingClientAsyncConnectionManager$InternalPoolEntryCallback:297 Connection leased: [id: 72][route: {}-&amp;gt;http://10.250.32.140:8082][total kept alive: 1; route allocated: 2 of 1000; total allocated: 2 of 5000]
2014.05.23 08:27:26.805 org.apache.cxf.transport.http.asyncclient.AsyncHTTPConduitFactory$3 DEBUG [HLAPI-68] DefaultAsyncRequestDirector:558 [exchange: 277] Connection allocated: [id:72][route:{}-&amp;gt;http://10.250.32.140:8082][state:null]
2014.05.23 08:27:46.838 org.apache.cxf.phase.PhaseInterceptorChain WARN  [HLAPI-68] LogUtils:452 Interceptor for {http://implementation.web.api.icc.services.osp.in.alcatel.com}SubscriberLineM
anagerPortTypeService#{http://implementation.web.api.icc.services.osp.in.alcatel.com}getAll has thrown exception, unwinding now
org.apache.cxf.interceptor.Fault: Could not send Message.
        at org.apache.cxf.interceptor.MessageSenderInterceptor$MessageSenderEndingInterceptor.handleMessage(MessageSenderInterceptor.java:64)
        at org.apache.cxf.phase.PhaseInterceptorChain.doIntercept(PhaseInterceptorChain.java:272)
        at org.apache.cxf.endpoint.ClientImpl.doInvoke(ClientImpl.java:570)
        at org.apache.cxf.endpoint.ClientImpl.invoke(ClientImpl.java:479)
        at org.apache.cxf.endpoint.ClientImpl.invoke(ClientImpl.java:382)
        at org.apache.cxf.endpoint.ClientImpl.invoke(ClientImpl.java:335)
        at org.apache.cxf.frontend.ClientProxy.invokeSync(ClientProxy.java:96)
        at org.apache.cxf.jaxws.JaxWsClientProxy.invoke(JaxWsClientProxy.java:135)
        at $Proxy88.getAll(Unknown Source)
        at sun.reflect.GeneratedMethodAccessor42.invoke(Unknown Source)
        at sun.reflect.DelegatingMethodAccessorImpl.invoke(DelegatingMethodAccessorImpl.java:25)
        at java.lang.reflect.Method.invoke(Method.java:597)
        at pl.infovide.inconfig.bep.backend.hlapi.HlapiCommunicator.send(HlapiCommunicator.java:212)
        at pl.infovide.inconfig.bep.backend.hlapi.HlapiBackend.send(HlapiBackend.java:26)
        at pl.infovide.inconfig.bep.backend.unified.UnifiedBackendImpl.forwardRequest(UnifiedBackendImpl.java:230)
        at pl.infovide.inconfig.bep.backend.unified.UnifiedBackendImpl.access$000(UnifiedBackendImpl.java:34)
        at pl.infovide.inconfig.bep.backend.unified.UnifiedBackendImpl$SenderTask.run(UnifiedBackendImpl.java:316)
        at java.util.concurrent.ThreadPoolExecutor$Worker.runTask(ThreadPoolExecutor.java:886)
        at java.util.concurrent.ThreadPoolExecutor$Worker.run(ThreadPoolExecutor.java:908)
        at java.lang.Thread.run(Thread.java:662)
Caused by: java.net.SocketTimeoutException: SocketTimeoutException invoking http://10.250.32.140:8082/HighLevelApiWS-2.4/services/SubscriberLineManager: Read Timeout
        at sun.reflect.NativeConstructorAccessorImpl.newInstance0(Native Method)
        at sun.reflect.NativeConstructorAccessorImpl.newInstance(NativeConstructorAccessorImpl.java:39)
        at sun.reflect.DelegatingConstructorAccessorImpl.newInstance(DelegatingConstructorAccessorImpl.java:27)
        at java.lang.reflect.Constructor.newInstance(Constructor.java:513)
        at org.apache.cxf.transport.http.HTTPConduit$WrappedOutputStream.mapException(HTTPConduit.java:1347)
        at org.apache.cxf.transport.http.HTTPConduit$WrappedOutputStream.close(HTTPConduit.java:1331)
        at org.apache.cxf.transport.http.asyncclient.AsyncHTTPConduit$AsyncWrappedOutputStream.close(AsyncHTTPConduit.java:383)
        at org.apache.cxf.io.CacheAndWriteOutputStream.postClose(CacheAndWriteOutputStream.java:56)
        at org.apache.cxf.io.CachedOutputStream.close(CachedOutputStream.java:223)
        at org.apache.cxf.transport.AbstractConduit.close(AbstractConduit.java:56)
        at org.apache.cxf.transport.http.HTTPConduit.close(HTTPConduit.java:632)
        at org.apache.cxf.interceptor.MessageSenderInterceptor$MessageSenderEndingInterceptor.handleMessage(MessageSenderInterceptor.java:62)
        ... 19 common frames omitted
Caused by: java.net.SocketTimeoutException: Read Timeout
        at org.apache.cxf.transport.http.asyncclient.AsyncHTTPConduit$AsyncWrappedOutputStream.getHttpResponse(AsyncHTTPConduit.java:583)
        at org.apache.cxf.transport.http.asyncclient.AsyncHTTPConduit$AsyncWrappedOutputStream.getResponseCode(AsyncHTTPConduit.java:674)
        at org.apache.cxf.transport.http.HTTPConduit$WrappedOutputStream.handleResponseInternal(HTTPConduit.java:1543)
        at org.apache.cxf.transport.http.HTTPConduit$WrappedOutputStream.handleResponse(HTTPConduit.java:1513)
        at org.apache.cxf.transport.http.HTTPConduit$WrappedOutputStream.close(HTTPConduit.java:1318)
        ... 25 common frames omitted
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;The connection allocated (id: 72) is never released to the connection pool.&lt;/p&gt;

&lt;p&gt;The main detail about scenario that causes the connection leak is no further activity during the exchange after connection allocation. In particular, there is no indication that the request processing has even started - the following line is missing from log (copied from correct exchange):&lt;/p&gt;

&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;2014.05.23 12:15:32.372 org.apache.cxf.transport.http.asyncclient.AsyncHTTPConduitFactory$3 DEBUG [I/O dispatcher 18] DefaultAsyncRequestDirector:313 [exchange: 5144] Attempt 1 to execute request
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;In other cases with the same exception, there are some bytes sent / events set on the exchange etc. and the connection is correctly aborted afterwards, but in this specific case the connection just leaks silently. Leaked connections accumulate in the pool and after some time make it unusable.&lt;/p&gt;

&lt;p&gt;Relevant configuration parameters:&lt;/p&gt;

&lt;p&gt;ReceiveTimeout=20000&lt;br/&gt;
ConnectionTimeout=20000&lt;br/&gt;
use.async.http.conduit=true&lt;/p&gt;

&lt;p&gt;Keep-alive time is 5000 ms.&lt;/p&gt;

&lt;p&gt;The problem is critical since with pool size of 1000 connections per route and using a single route, we are forced to restart our service every 1-2 months and are unable to provide high availability requested by our business client.&lt;/p&gt;

&lt;p&gt;A workaround for us would be to use the default, synchronous HTTP Transport, however we have noticed that sometimes it attempts to send a request via a connection that is already half-closed by the server side. Has this issue been diagnosed / fixed?&lt;/p&gt;</description>
                <environment>&lt;p&gt;SunOS 5.10 Generic_147440-25 sun4v sparc SUNW,SPARC-Enterprise-T5120, 64bit&lt;/p&gt;</environment>
        <key id="12716312">CXF-5762</key>
            <summary>Connection leak after SocketTimeoutException using Asynchronous Client HTTP Transport</summary>
                <type id="1" iconUrl="https://issues.apache.org/jira/secure/viewavatar?size=xsmall&amp;avatarId=21133&amp;avatarType=issuetype">Bug</type>
                                            <priority id="3" iconUrl="https://issues.apache.org/jira/images/icons/priorities/major.svg">Major</priority>
                        <status id="6" iconUrl="https://issues.apache.org/jira/images/icons/statuses/closed.png" description="The issue is considered finished, the resolution is correct. Issues which are not closed can be reopened.">Closed</status>
                    <statusCategory id="3" key="done" colorName="green"/>
                                    <resolution id="1">Fixed</resolution>
                                        <assignee username="dkulp">Daniel Kulp</assignee>
                                    <reporter username="poltarzewski">Przemys&#322;aw O&#322;tarzewski</reporter>
                        <labels>
                    </labels>
                <created>Fri, 23 May 2014 11:34:46 +0000</created>
                <updated>Fri, 31 Mar 2017 19:38:46 +0000</updated>
                            <resolved>Fri, 24 Mar 2017 14:15:24 +0000</resolved>
                                    <version>2.7.11</version>
                                    <fixVersion>3.1.10</fixVersion>
                                    <component>Transports</component>
                        <due></due>
                            <votes>0</votes>
                                    <watches>6</watches>
                                                                                                                <comments>
                            <comment id="14240692" author="rprosenjit" created="Wed, 10 Dec 2014 05:50:32 +0000"  >&lt;p&gt;We are using CXF 2.7.10 and http core nio 4.2.4 and experiencing exact same issue on production (Solaris). But we couldn&apos;t replicate it in any of our development environments (windows, solaris, ubuntu) yet. &lt;br/&gt;
Observation: When a client read time-out happens in production, it cannot close the IOSession gracefully and causes associated connection to be blocked due to open IOSession and it keeps trying to send bytes to server even though no valid TCP socket exists at stack level. Hence, we see a loop of &quot;produce content....&quot; message in respective logs.&lt;br/&gt;
Upon analyzing logs and digging more it seems that while time-out occurs due to response delay from server (i.e. response time exceeds client&apos;s receive time out) BaseIOReactor is not able to close the active IOSession and hence not allowing to release the connection back to free pool.&lt;br/&gt;
We are yet to figure out what leads to this abnormal behavior and still trying to pin point it. Therefore any help will be much appreciated. Thank you!&lt;/p&gt;</comment>
                            <comment id="14246335" author="rprosenjit" created="Mon, 15 Dec 2014 05:34:12 +0000"  >&lt;p&gt;Finally we figured out the steps to replicate similar issue in any development environment. Here are the steps that we followed:-&lt;br/&gt;
1) Set read-timeout = 5000ms, SoapUI mock service response delay = 4900ms, select interval as default i.e. 1000ms&lt;br/&gt;
2) With above settings when we triggered several requests, we noticed behavior as follows -&lt;br/&gt;
     a) Once request is sent successfully, it waits for a response and after around 4800ms AsyncHTTPConduit shuts shared input/output buffer down and throws a SocketTimeoutException. Incidentally, connection and associated IOSession are still active at that time and are waiting to be closed by timeout check initiated by IOReactor.&lt;br/&gt;
     b) At around 4900ms, IODispatcher receives the 1st slice of chunk response and as response is not fully arrived yet, it makes ChunkDecoder&apos;s complete flag as &apos;false&apos;.&lt;br/&gt;
     c) Then it invokes SharedInputBuffer.consumeContent() to read contents from ContentDecoder to buffer. But it finds that buffer is already down and so it shuts the connection down and return from the method.&lt;br/&gt;
           if (this.shutdown) &lt;/p&gt;
{
89             //something bad happened, we need to shutdown the connection
90             //as we&apos;re not going to read the data at all and we
91             //don&apos;t want to keep getting read notices and such
92             ioc.shutdown();
93             return -1;
94         }

&lt;p&gt;d) Control returns to HttpAsyncRequestExecutor.inputReady() where it checks if decoder.isCompleted() = true and if yes then calls processResponse which in turn releases the connection. But as the complete ContentDecoder.complete = false, in given case code never executes processResponse and therefore releases connection back to pool.&lt;/p&gt;

&lt;p&gt;To resolve this issue, we just updated below &apos;IF&apos; check in HttpAsyncRequestExecutor.inputReady() to add a verification on connection as follows -&lt;br/&gt;
	if (decoder.isCompleted() || !conn.isOpen()) &lt;/p&gt;
{
            processResponse(conn, state, handler);
        }

&lt;p&gt;Same has been done for HttpAsyncRequestExecutor.outputReady method.&lt;/p&gt;

&lt;p&gt;Post change we see that connection is gracefully released even for above race condition and it doesn&apos;t introduce connection pool lock any more. &lt;/p&gt;</comment>
                            <comment id="14246474" author="olegk" created="Mon, 15 Dec 2014 09:08:03 +0000"  >&lt;p&gt;&lt;a href=&quot;https://issues.apache.org/jira/secure/ViewProfile.jspa?name=rprosenjit&quot; class=&quot;user-hover&quot; rel=&quot;rprosenjit&quot;&gt;rprosenjit&lt;/a&gt;: Please upgrade HttpCore to version 4.3.3. I suspect the problem you are having is the same as &lt;a href=&quot;https://issues.apache.org/jira/browse/HTTPASYNC-69&quot; title=&quot;calling IOControl.shutdown() doesn&amp;#39;t release the underlying connection&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HTTPASYNC-69&quot;&gt;&lt;del&gt;HTTPASYNC-69&lt;/del&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Oleg&lt;/p&gt;</comment>
                            <comment id="14247795" author="rprosenjit" created="Tue, 16 Dec 2014 05:33:04 +0000"  >&lt;p&gt;Oleg, I really appreciate that you followed it up and offered your suggestion. I really wish to adopt a fix provided by core cxf team instead of going with a custom patch. Hence I upgraded httpcore and httpcore-nio to version 4.3.3. Unfortunately post upgrade, it throws an exception for each and every request. Here is a snippet of it -&lt;br/&gt;
java.lang.IllegalStateException: Buffer already closed for writing&lt;br/&gt;
	at org.apache.cxf.transport.http.asyncclient.SharedOutputBuffer.write(SharedOutputBuffer.java:231)&lt;br/&gt;
	at org.apache.cxf.transport.http.asyncclient.AsyncHTTPConduit$AsyncWrappedOutputStream$1.write(AsyncHTTPConduit.java:397)&lt;br/&gt;
	at java.io.ByteArrayOutputStream.writeTo(ByteArrayOutputStream.java:154)&lt;br/&gt;
	at org.apache.cxf.io.CachedOutputStream.writeCacheTo(CachedOutputStream.java:312)&lt;br/&gt;
	at org.apache.cxf.transport.http.asyncclient.AsyncHTTPConduit$AsyncWrappedOutputStream.close(AsyncHTTPConduit.java:379)&lt;/p&gt;

&lt;p&gt;Due to this we are not able to proceed with the suggested approach. Hence, can you please confirm if the patch that we followed is of any concern or has any side-effect. If not, then for now we can use this to get rid of our production issue.&lt;/p&gt;

&lt;p&gt;Thank you!&lt;/p&gt;</comment>
                            <comment id="14247942" author="olegk" created="Tue, 16 Dec 2014 08:39:23 +0000"  >&lt;p&gt;I do not think the patch is correct, but if it fixes the problem for you and causes no side effects it is probably as good as it gets.&lt;/p&gt;

&lt;p&gt;Oleg&lt;/p&gt;</comment>
                            <comment id="14248555" author="rprosenjit" created="Tue, 16 Dec 2014 17:51:30 +0000"  >&lt;p&gt;Again thank you for your response, Oleg. Yes I understand the fix that we applied may not be an optimal one considering broader view of CXF but with all constraints we have i.e. upgrading only httpcore and httpcore-nio to 4.3.3 didn&apos;t help us and also to certify our code with all latest CXF lib with their dependencies may need significant effort and time, we thought to keep the change minimal. Hence we see that in the given case even though connection and IOSession are getting down but the decoder associated with that connection remains incomplete and hence not invoking code to release the connection. So only thing we wanted to achieve is to release the connection while decoder is not complete but associated connection is closed. &lt;br/&gt;
Anyway, I checked the &lt;a href=&quot;https://issues.apache.org/jira/browse/HTTPASYNC-69&quot; title=&quot;calling IOControl.shutdown() doesn&amp;#39;t release the underlying connection&quot; class=&quot;issue-link&quot; data-issue-key=&quot;HTTPASYNC-69&quot;&gt;&lt;del&gt;HTTPASYNC-69&lt;/del&gt;&lt;/a&gt; code fix that you did to release the connection via IOReactor.processClosedSessions call and applied the same for 4.2.4 code. With this I tested again and it seems to be working fine too. Below are the lines that I added in HttpAsyncRequestExecutor.closed(conn) method-&lt;br/&gt;
if (state != null) {&lt;br/&gt;
			if (state.getRequestState() != MessageState.READY&lt;/p&gt;
&lt;div class=&apos;table-wrap&apos;&gt;
&lt;table class=&apos;confluenceTable&apos;&gt;&lt;tbody&gt;
&lt;tr&gt;
&lt;th class=&apos;confluenceTh&apos;&gt; state.getResponseState() != MessageState.READY) 
&lt;div class=&quot;error&quot;&gt;&lt;span class=&quot;error&quot;&gt;Unknown macro: {				if (handler != null) {
					handler.failed(new ConnectionClosedException(
							&quot;Connection closed unexpectedly&quot;));
				}			}&lt;/span&gt; &lt;/div&gt;
&lt;p&gt;		}&lt;/p&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/tbody&gt;&lt;/table&gt;
&lt;/div&gt;


&lt;p&gt;Please suggest if you think that this is a better hanlding than what we had earlier.&lt;/p&gt;</comment>
                            <comment id="14249627" author="olegk" created="Wed, 17 Dec 2014 08:38:41 +0000"  >&lt;p&gt;I do think this is a better fix.&lt;/p&gt;

&lt;p&gt;Oleg&lt;/p&gt;</comment>
                            <comment id="14250756" author="rprosenjit" created="Wed, 17 Dec 2014 23:02:50 +0000"  >&lt;p&gt;Thank you for confirmation, Oleg! Happy Christmas and holidays &lt;img class=&quot;emoticon&quot; src=&quot;https://issues.apache.org/jira/images/icons/emoticons/smile.png&quot; height=&quot;16&quot; width=&quot;16&quot; align=&quot;absmiddle&quot; alt=&quot;&quot; border=&quot;0&quot;/&gt;&lt;/p&gt;</comment>
                            <comment id="14251779" author="dkulp" created="Thu, 18 Dec 2014 15:15:59 +0000"  >&lt;p&gt;Can I ask if there is anything we need to do in CXF other than pick up the next version of httpcore-nio?  Kind of confused by the back and forth above.&lt;/p&gt;</comment>
                            <comment id="14251784" author="olegk" created="Thu, 18 Dec 2014 15:21:17 +0000"  >&lt;p&gt;Nothing I could think of. I am not sure what might be causing the exception below though but it appears to be related to state management in SharedOutputBuffer, which looks CXF specific to me.&lt;/p&gt;
&lt;div class=&quot;preformatted panel&quot; style=&quot;border-width: 1px;&quot;&gt;&lt;div class=&quot;preformattedContent panelContent&quot;&gt;
&lt;pre&gt;java.lang.IllegalStateException: Buffer already closed for writing
at org.apache.cxf.transport.http.asyncclient.SharedOutputBuffer.write(SharedOutputBuffer.java:231)
at org.apache.cxf.transport.http.asyncclient.AsyncHTTPConduit$AsyncWrappedOutputStream$1.write(AsyncHTTPConduit.java:397)
at java.io.ByteArrayOutputStream.writeTo(ByteArrayOutputStream.java:154)
at org.apache.cxf.io.CachedOutputStream.writeCacheTo(CachedOutputStream.java:312)
at org.apache.cxf.transport.http.asyncclient.AsyncHTTPConduit$AsyncWrappedOutputStream.close(AsyncHTTPConduit.java:379)
&lt;/pre&gt;
&lt;/div&gt;&lt;/div&gt;

&lt;p&gt;Oleg&lt;/p&gt;</comment>
                            <comment id="15940421" author="dkulp" created="Fri, 24 Mar 2017 14:15:24 +0000"  >&lt;p&gt;Resolved a while ago via upgrade to latest http stuff&lt;/p&gt;</comment>
                    </comments>
                    <attachments>
                    </attachments>
                <subtasks>
                    </subtasks>
                <customfields>
                                                                            <customfield id="customfield_12310310" key="com.atlassian.jira.toolkit:attachments">
                        <customfieldname>Attachment count</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0.0</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                    <customfield id="customfield_12314020" key="com.atlassian.jira.plugins.jira-development-integration-plugin:devsummary">
                        <customfieldname>Development</customfieldname>
                        <customfieldvalues>
                            
                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12313422" key="com.atlassian.jirafisheyeplugin:jobcheckbox">
                        <customfieldname>Enable Automatic Patch Review</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue><![CDATA[false]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                        <customfield id="customfield_12310060" key="com.atlassian.jira.plugin.system.customfieldtypes:select">
                        <customfieldname>Estimated Complexity</customfieldname>
                        <customfieldvalues>
                                <customfieldvalue key="10060"><![CDATA[Unknown]]></customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                        <customfield id="customfield_12310420" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Global Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>394520</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                        <customfield id="customfield_12312521" key="com.atlassian.jira.toolkit:LastCommentDate">
                        <customfieldname>Last public comment date</customfieldname>
                        <customfieldvalues>
                            6 years, 10 weeks ago
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                <customfield id="customfield_12311820" key="com.pyxis.greenhopper.jira:gh-lexo-rank">
                        <customfieldname>Rank</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>0|i1vxfb:</customfieldvalue>

                        </customfieldvalues>
                    </customfield>
                                                                <customfield id="customfield_12310920" key="com.pyxis.greenhopper.jira:gh-global-rank">
                        <customfieldname>Rank (Obsolete)</customfieldname>
                        <customfieldvalues>
                            <customfieldvalue>394661</customfieldvalue>
                        </customfieldvalues>
                    </customfield>
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                            </customfields>
    </item>
</channel>
</rss>